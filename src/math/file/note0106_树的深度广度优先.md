
# 树的深度优先搜索(上):如何才能高效率地查字典?

对应的数据结构就是前缀树(prefix tree)，或者叫字典树(trie)

# 前缀树的构建和查询

前缀树的构建和查询这两者在本质上其实是一致的。构建的时候，我们需要根据当前的前缀进行 查询，
然后才能找到合适的位置插入新的结点。而且，这两者都存在一个不断重复迭代的查找过 程，我们把
这种方式称为深度优先搜索(Depth First Search)。


如果到了某个点，发现和这个点直接相连的所有点都已经被访问过，那么就回退到在这个点的父 结点，
继续查看是否有新的点可以访问;如果没有就继续回退，一直到出发点。由于单棵树中所 有的结点都是
连通的，所以通过深度优先的策略可以遍历树中所有的结点，因此也被称为深度优 先遍历。

# 如何使用数据结构表达树?


# 如何使用递归和栈实现深度优先搜索?

仔细观察前缀树构建和查询，你会发现这两个不断重复迭代的过程，都可以使用递归编程来实 现。
换句话说，深度优先搜索的过程和递归调用在逻辑上是一致的。


尽管函数递归调用非常直观，可是也有它自身的弱点。函数的每次嵌套，都可能产生新的变量来 保存中间结果，
这可能会消耗大量的内存。所以这里我们可以用一个更节省内存的数据结构，栈 (Stack)。


1 // 使用栈来实现深度优先搜索
就是 二叉树遍历的 非递归先序遍历



# 树的广度优先搜索(上):人际关系的六度理论是真的吗?


# 深度优先搜索面临的问题

更高效的做法是，我们只需要先找到所有二度的好友，如果二度好友不够了，再去找三度或者四
度的好友。这种好友搜索的模式，其实就是我们今天要介绍的广度优先搜索。
广度优先搜索(Breadth First Search)，也叫宽度优先搜索，


带你看一下广度优先搜索和深度优先搜索，在结点访问的顺序上有什么不一样。

在遍历树或者图的时候，如果使用深度优先的策略，被发现的结点数量可能呈指数级增长。如果
我们更关心的是最近的相连结点，比如社交关系中的二度好友，那么这种情况下，广度优先策略
更高效。也正是由于这种特性，我们不能再使用递归编程或者栈的数据结构来实现广度优先，而
是需要用到具有先进先出特点的队列。


# 树的广度优先搜索(下):为什么双向广度优先搜索的效率更高?

































