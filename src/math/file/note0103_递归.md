
# 递归

限定总和的情况下，求所有可能的加和方式

例子

在第一次奖赏 1 元，第二次奖赏 1 元后，总和为 2 元;第一次奖赏 1 元，
第二次奖赏 2 元后，总和为 3 元;第一次奖赏 1 元，第二次奖赏 5 元后，
总和为 6 元。好吧，这还没有考虑 第一次奖赏 2 元和 5 元的情况。
画个图，从图中你就能发现这种可能的情况在快速地“膨 胀”。


虽然迭代法的思想是可行的，但是如果用循环来实现，恐怕要保存好多中间状态 及其对应的变量。
说到这里，你是不是很容易就想到计算编程常用的函数递归?

在递归中，每次嵌套调用都会让函数体生成自己的局部变量，正好可以用来保存不同状态下的数
值，为我们省去了大量中间变量的操作，极大地方便了设计和编程。



# 如何把复杂的问题简单化?

如何将数学归纳法的思想泛化成更一般的情况?


1. 初始状态，也就是 n=1 的时候，命题是否成立;
2. 如果 n=k-1 的时候，命题成立。那么只要证明 n=k 的时候，命题也成立。其中 k 为大于 1 的自然数。

将上述两点顺序更换一下，再抽象化一下，我写出了这样的递推关系:

1. 假设 n=k-1 的时候，问题已经解决(或者已经找到解)。那么只要求解 n=k 的时候，问题 如何解决(或者解是多少);
2. 初始状态，就是 n=1 的时候，问题如何解决(或者解是多少)。


复杂的问题，每次都解决一点点，并将剩下的任务转化成为更简单的问题
等待下次求解，如此反复，直到最简单的形式



# 小结1

递归和循环其实都是迭代法的实现，而且在某些场合下，它们的实现是可以相互转化的。但是，
对于某些应用场景，递归确很难被循环取代。我觉得主要有两点原因:

第一，递归的核心思想和数学归纳法类似，并更具有广泛性。这两者的类似之处体现在:将当前
的问题化解为两部分:一个当前所采取的步骤和另一个更简单的问题。


第二，递归会使用计算机的函数嵌套调用。而函数的调用本身，就可以保存很多中间状态和变量
值，因此极大的方便了编程的处理。


# 分而治之，从归并排序到MapReduce


# 归并排序中的分治思想

归并排序算法的核心就是“归并”，也就是把两个有序的数列合并起来，形成一个更大
的有序数列。
>  重点是  两个有序的数列


假设我们需要按照从小到大的顺序，合并两个有序数列 A 和 B。这里我们需要开辟一个新的存 储空间 C，用于保存合并后的结果。

> 要开辟新的村到户空间，就是空间复杂度



```  
分而治之，我 们通常简称为分治。它的思想就是，将一个复杂的问题，
分解成两个甚至多个规模相同或类似的 子问题，然后对这些子问题再
进一步细分，直到最后的子问题变得很简单，很容易就能被求解出 来，
这样这个复杂的问题就求解出来了。

```

归并排序使用了分治的思想，而这个过程需要使用递归来实现。

分治的过程是不是和递归的过程一致呢?



# 分布式系统中的分治思想



当需要排序的数组很大(比如达到 1024GB 的时候)，我们没法把这些数据都塞入一台 
普通机器的内存里。该怎么办呢?有一个办法，我们可以把这个超级大的数据集，分解
为多个更 小的数据集(比如 16GB 或者更小)，然后分配到多台机器，让它们并行地处理。

> 那么怎么分， 分完之后怎么办


等所有机器处理完后，中央服务器再进行结果的合并 (怎么合并？)


而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机
器上。


``` 
A: 
 
                        机器1
                        
                  机器2       机器3
                  
            机器4   机器5   机器6   机器7       

B:

                        机器1
                        
                  机器1       机器2
                  
            机器1   机器3   机器1   机器4      


```


例如机器 1、2、3，它们都没有被分配排序的工作，只是在子结点的排序完成 后进行有序数组的合并，
因此集群的性能没有得到充分利用。那么，另一种可能的数据切分方式 是，每台机器拿出一半的数据给
另一台机器处理，而自己来完成剩下一半的数据。



MP

这里面主要有三个步骤用到了分治的思想。

1. 数据分割和映射

分割是指将数据源进行切分，并将分片发送到 Mapper 上

映射是指 Mapper 根据应用的需 求，将内容按照键 - 值的匹配，存储到哈希结构中

这两个步骤将大的数据集合切分为更小的数 据集，降低了每台机器节点的负载，因此和分治中的问题分解类似。

不过，MapReduce 采用了 哈希映射来分配数据，而普通的分治或递归不一定需要。


2. 归约

由于哈希映射的关系，MapReduce 还需要洗牌的步骤， 也就是将键 - 值的配对不断地发给对应的 Reducer 进行归约

普通的分治或递归不一定需要洗 牌的步骤。


3. 合并

为了提升洗牌阶段的效率，可以选择减少发送到归约阶段的键 - 值配对。具体做法是在数据映射 和洗牌之间，
加入合并的过程，在每个 Mapper 节点上先进行一次本地的归约。然后只将合并 的结果发送到洗牌和归约阶段。
这和本机的递归调用后返回结果的过程类似。




```  
分治问题适合使用递归来实现。同时，分治的思想也可以帮助我
们设计分布式系统和并行计算，细分后的问题交给不同的机器来处理，
而其中的某些机器专门负责收集来自不同机器的处理结果，完成结果的合并。
```




































































